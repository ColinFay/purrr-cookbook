[
["webmining.html", "Chapter 4 Webmining 4.1 Status code 4.2 Check status code 4.3 Scrape a list of urls which may fail 4.4 Getting h2 4.5 JSON with many levels 4.6 Several API call", " Chapter 4 Webmining 4.1 Status code 4.1.1 I want to… Create a status code checker. 4.1.2 Here’s how to library(httr) get_status &lt;- compose(status_code, GET) get_status(&quot;colinfay.me&quot;) ## [1] 200 4.1.3 Ok, but why? compose(y, x) composes a function that will do y(x()). So here, get_status(&quot;url&quot;) will do status_code(GET(&quot;url&quot;)). 4.1.4 See also 4.2 Check status code 4.2.1 I want to… Check for http status code for a list of pages. 4.2.2 Here’s how to urls &lt;- c(&quot;http://colinfay.me&quot;, &quot;http://thinkr.fr&quot;, &quot;reallynotanadress&quot;) get_status &lt;- compose(status_code, GET) map(urls, get_status) %&gt;% every(~ .x == 200) ## [1] FALSE 4.2.3 Ok, but why? 200 is a status code that indicates that the connexion went smoothly. The every function here checks if all the status code we just GET are equal to 200. 4.2.4 See also 4.3 Scrape a list of urls which may fail 4.3.1 I want to… Launch a read_html function on a list of webpages, and some may throw an error. The difference with the function we saw previously ? # http status code error GET(&quot;notexistingurl&quot;) ## Response [http://notexistingurl/] ## Date: 2018-01-19 21:33 ## Status: 403 ## Content-Type: text/html; charset=iso-8859-1 ## Size: 202 B ## &lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt; ## &lt;html&gt;&lt;head&gt; ## &lt;title&gt;403 Forbidden&lt;/title&gt; ## &lt;/head&gt;&lt;body&gt; ## &lt;h1&gt;Forbidden&lt;/h1&gt; ## &lt;p&gt;You don&#39;t have permission to access / ## on this server.&lt;/p&gt; ## &lt;/body&gt;&lt;/html&gt; # Error because host doesn&#39;t exist GET(&quot;notexistingurl.org&quot;) ## Error in curl::curl_fetch_memory(url, handle = handle): Could not resolve host: notexistingurl.org 4.3.2 Here’s how to library(rvest) urls &lt;- c(&quot;http://colinfay.me&quot;, &quot;http://thinkr.fr&quot;, &quot;reallynotanadress&quot;) possible_read &lt;- possibly(read_html, otherwise = NULL) map(urls, possible_read) %&gt;% set_names(urls) %&gt;% compact() ## $`http://colinfay.me` ## {xml_document} ## &lt;html lang=&quot;en&quot; class=&quot;no-js&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset= ... ## [2] &lt;body class=&quot;layout--home&quot;&gt;\\n\\n &lt;!--[if lt IE 9]&gt;\\n&lt;div class=&quot;no ... ## ## $`http://thinkr.fr` ## {xml_document} ## &lt;html class=&quot;no-js&quot; lang=&quot;fr-FR&quot;&gt; ## [1] &lt;head&gt;\\n&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset= ... ## [2] &lt;body class=&quot;home page-template-default page page-id-35625 do-etfw f ... 4.3.3 Ok, but why possibly turns a function into another function that returns what is defined in otherwise in case of failure. Here, we chose to return NULL. compact() removes all the elements from a list which are NULL. 4.3.4 See also R for Data Science - 21.6 Dealing with failure 4.4 Getting h2 4.4.1 I want to… Get the h2s from a list of urls. 4.4.2 Here’s how to get_h2 &lt;- compose(html_text, as_mapper(~ html_nodes(.x, &quot;h2&quot;)), read_html) urls &lt;- c(&quot;http://colinfay.me&quot;, &quot;http://thinkr.fr&quot;) map(urls, get_h2) %&gt;% set_names(urls) ## $`http://colinfay.me` ## [1] &quot;On the blog : &quot; ## [2] &quot;\\n \\n Combining the new {rtweet} and {tidytext}\\n\\n \\n &quot; ## [3] &quot;\\n \\n [How to] Include a dancing banana in your R package documentation\\n\\n \\n &quot; ## [4] &quot;\\n \\n Some random R benchmarks\\n\\n \\n &quot; ## [5] &quot;\\n \\n {attempt} is now on CRAN\\n\\n \\n &quot; ## [6] &quot;\\n \\n A Crazy Little Thing Called {purrr} - Part 6 : doing statistics\\n\\n \\n &quot; ## ## $`http://thinkr.fr` ## [1] &quot;Conseil, développement et formation au logiciel R&quot; ## [2] &quot;Formez-vous au logiciel R !&quot; ## [3] &quot;\\r\\n\\t\\tLe logo ThinkR créé avec la librairie {sf}\\r\\n\\t&quot; ## [4] &quot;\\r\\n\\t\\tR de jeu #2 : Happy new yeaR\\r\\n\\t&quot; ## [5] &quot;\\r\\n\\t\\tDe retour de Budapest\\r\\n\\t&quot; ## [6] &quot;\\r\\n\\t\\tR de jeu #1 : API, dataviz, et statistiques\\r\\n\\t&quot; ## [7] &quot;\\r\\n\\t\\tforcats, forcats, vous avez dit forcats ?\\r\\n\\t&quot; ## [8] &quot;\\r\\n\\t\\tText mining et topic modeling avec R\\r\\n\\t&quot; ## [9] &quot;\\r\\n\\t\\tÀ la découverte de {rvest}\\r\\n\\t&quot; ## [10] &quot;\\r\\n\\t\\tPremiers pas en Machine Learning avec R. Volume 4 : random forest\\r\\n\\t&quot; ## [11] &quot;\\r\\n\\t\\tAu menu du jour : {R6} — Partie 2\\r\\n\\t&quot; 4.4.3 Ok, but why? We are composing an h2 extractor by combining read_html, html_nodes and html_text. We then map this extractor to a list of urls, before setting the names of the results with the set_names function. 4.4.4 See also 4.5 JSON with many levels 4.5.1 I want to… Extract all the test1 results. 4.5.2 Here’s how to: map(json_file, ~ purrr::pluck(.x, &quot;Res&quot;, &quot;test1&quot;)) ## $obs1 ## [1] &quot;17&quot; ## ## $obs2 ## [1] &quot;12&quot; 4.5.3 Ok, but why What we called before is a shortcut for map(file, ~ pluck(.x, &quot;id&quot;). That shortcut works on the first level of the list. If you need to go deeper, you need to explicitely specify the pluck call. Be careful, there is also a pluck in {rvest} that doesn’t behave exactly as the pluck from {purrr}. map(json_file, ~ rvest::pluck(.x, &quot;Res&quot;, &quot;test1&quot;)) ## Error in FUN(X[[i]], ...): indice hors limites 4.5.4 See also 4.6 Several API call 4.6.1 I want to… Make a series of API calls 4.6.2 Here’s how to: library(attempt) library(curl) caller &lt;- function(x){ # verify internet connexion stop_if_not(has_internet(), msg = &quot;You should have internet to do that&quot;) res &lt;- GET(url = &quot;https://geo.api.gouv.fr/communes&quot;, query = list(nom = x)) res$content %&gt;% rawToChar() %&gt;% jsonlite::fromJSON(simplifyDataFrame = TRUE) } city &lt;- c(&quot;Rennes&quot;,&quot;Vannes&quot;,&quot;Brest&quot;) map_df(city, caller) nom code codeDepartement codeRegion codesPostaux population _score Rennes 35238 35 53 35000, 35200, 35700 211373 1.0000000 Rennes-le-Château 11309 11 76 11190 58 0.7761594 Rennes-les-Bains 11310 11 76 11190 258 0.7583585 Rennes-sur-Loue 25488 25 27 25440 88 0.6743168 Rennes-en-Grenouilles 53189 53 52 53110 117 0.6239261 Vannes 56260 56 53 56000 53032 1.0000000 Vannes-le-Châtel 54548 54 44 54112 579 0.7510264 Pouy-sur-Vannes 10301 10 44 10290 145 0.6873107 Saulxures-lès-Vannes 54496 54 44 54170 363 0.6820142 Vannes-sur-Cosson 45331 45 24 45510 589 0.6652302 Brest 29019 29 53 29200 139386 0.7182376 Brestot 27110 27 28 27350 518 0.6957980 Esboz-Brest 70216 70 27 70300 485 0.4918154 4.6.3 Ok, but why? Here, we are calling an API which returns a JSON object that can be easily turned into a df with {jsonlite}. So we choose to use map_df to return a simple data.frame of the three results. 4.6.4 See also "]
]
